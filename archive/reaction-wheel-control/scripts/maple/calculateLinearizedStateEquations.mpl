w_s:=<w_s1,w_s2,w_s3>; # Angular velocity of satellite (rad/s)
I_s:=<<I_s11,I_s21,I_s31>|
      <I_s12,I_s22,I_s32>|
      <I_s13,I_s23,I_s33>>; # Satellite inertia matrix (kg m^2)
I_inverse_s:=<<I_inverse_s11,I_inverse_s21,I_inverse_s31>|
              <I_inverse_s12,I_inverse_s22,I_inverse_s32>|
              <I_inverse_s13,I_inverse_s23,I_inverse_s33>>; # Inverse of I_s
h:=<h_rw1, h_rw2, h_rw3>; # Angular momentum of reaction wheels (kg m^2 / s)
S:=<<  0  , w_s3,-w_s2>|
    <-w_s3,  0  , w_s1>|
    < w_s2,-w_s1,  0  >>; # Vector cross product of w_s (e.g. w_s X ...)

q:=<q_1,q_2,q_3,q_4>; # Quaternion vector
Omega:=<<  0  ,-w_s3, w_s2,-w_s1>|
        < w_s3,  0  ,-w_s1,-w_s2>|
        <-w_s2, w_s1,  0  ,-w_s3>|
        < w_s1, w_s2, w_s3,  0  >>; 
dq:=1/2*Omega.q; # Time rate of change of q

g:=<q_1,q_2,q_3>; # Gibbs vector
dg:=-1/2*S.q+1/2*q_4*Matrix(3,shape=identity).w_s; 

dw:= -I_inverse_s.S.I_s.w_s-I_inverse_s.S.h;
dg:=-1/2*Matrix(3,shape=identity).w_s; # dg with linearization approximations
dh_rw:=<dh_rw1,dh_rw2,dh_rw3>; # Also input vector
T_c:=-1*dh_rw; # Control torque generated by reaction wheels
T_e:=<T_e1, T_e2, T_e3>; # External disturbance torques
dw_no_inverse:= -S.I_s.w_s-S.h+T_c+T_e;
f:=<dw_no_inverse, dg, -1*T_c>; # Non-linear state vector

x:=<w_s1,w_s2,w_s3,q_1,q_2,q_3,h_rw1,h_rw2,h_rw3>; # Linearized state vector
u:=dh_rw;

A:=Matrix(9); 
for i from 1 to 9 do 
    for j from 1 to 9 do 
        A[i,j]:=simplify(diff(f[i],x[j])); # Definition of Jacobian
    end do;
end do;
A;

Bu:=Matrix(9,3);
for i from 1 to 9 do
    for j from 1 to 3 do
        Bu[i,j]:=-1*diff(f[i],u[j]);
    end do;
end do;
Bu;

Be:=Matrix(9,3);
for i from 1 to 9 do
    for j from 1 to 3 do
        Be[i,j]:=-1*diff(f[i],T_e[j]);
    end do;
end do;
Be;
